<!DOCTYPE html>
<html lang="en">

<head>
    <script src="/js/script.js" defer></script>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-4T90FQG02K"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-4T90FQG02K');
    </script>
    <!-- AdSense account verification -->
    <meta name="google-adsense-account" content="ca-pub-7933209486512555">

    <!-- AdSense Auto Ads -->
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7933209486512555"
        crossorigin="anonymous"></script>
    <meta charset="utf-8" />
    <title>Duplicate File Finder ‚Äî RDroid Apps</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link rel="canonical" href="https://rdroidapps.com/windows-tools/system/duplicate-file-finder.html" />
    <link rel="stylesheet" href="/css/style.css">
    <meta name="description"
        content="Find and remove duplicate files by comparing size, content, name, or hash. Recover disk space by deleting unnecessary duplicates." />
    <meta name="keywords"
        content="duplicate file finder, duplicate files, remove duplicates, duplicate photos, duplicate documents, free up disk space" />
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>

</head>

<body>
    <!-- HEADER -->
    <div id="header-container"></div>

    <!-- TOOLS QUICK LINKS -->
    <div id="tools-links-container"></div>

    <!-- MENU DRAWER -->
    <div id="menu-drawer-container"></div>

    <!-- Load components -->
    <script>
        $(function () {
            $("#header-container").load("/components/header.html");
            $("#menu-drawer-container").load("/components/menu-drawer.html");
            $("#tools-links-container").load("/components/system-tools-quick-links.html");
            $("#footer-container").load("/components/footer.html");
        });
    </script>

    <section class="section" role="main" aria-labelledby="title">
        <h1 id="title">Duplicate File Finder</h1>
        <p class="lead">Find and remove duplicate files by comparing size, content, name, or hash. Recover disk space by
            deleting unnecessary duplicates. All processing happens locally in your browser.</p>

        <div class="card" style="margin-top: 24px;">
            <div class="drop" id="dropArea">
                <p>üîç Drop files/folders here to scan for duplicates</p>
                <p class="small">or</p>
                <button class="btn" id="chooseBtn">Choose Files/Folders</button>
                <input type="file" id="fileInput" webkitdirectory multiple style="display:none" />
                <p class="small" style="margin-top: 12px;">For folder scanning, use Chrome/Edge. For other browsers,
                    select
                    multiple files.</p>
            </div>

            <div class="controls" style="margin-top: 20px;">
                <div class="control">
                    <label>Scan Method</label>
                    <select id="scanMethod">
                        <option value="quick">Quick Scan (File Size & Name)</option>
                        <option value="content">Content Comparison</option>
                        <option value="hash">Hash Comparison (MD5/SHA-1)</option>
                        <option value="advanced">Advanced Comparison</option>
                    </select>
                </div>
                <div class="control">
                    <label>File Types to Scan</label>
                    <select id="fileTypes">
                        <option value="all">All File Types</option>
                        <option value="images">Images Only (JPG, PNG, GIF)</option>
                        <option value="documents">Documents Only (PDF, DOC, TXT)</option>
                        <option value="media">Media Files (MP3, MP4, AVI)</option>
                        <option value="custom">Custom Types</option>
                    </select>
                    <input type="text" id="customTypes" placeholder=".jpg,.png,.pdf"
                        style="margin-top: 8px; display: none;">
                </div>
                <div class="control">
                    <label>Minimum File Size</label>
                    <select id="minSize">
                        <option value="0">Any Size</option>
                        <option value="1024">> 1 KB</option>
                        <option value="1048576" selected>> 1 MB</option>
                        <option value="10485760">> 10 MB</option>
                        <option value="104857600">> 100 MB</option>
                    </select>
                </div>
            </div>

            <div class="advanced-controls" style="margin-top: 15px; display: none;" id="advancedOptions">
                <div class="adv-col">
                    <label class="small">Comparison Algorithm</label>
                    <select id="hashAlgorithm">
                        <option value="md5">MD5 (Fast)</option>
                        <option value="sha1">SHA-1 (Reliable)</option>
                        <option value="sha256">SHA-256 (Secure)</option>
                    </select>
                </div>
                <div class="adv-col">
                    <label class="small">Byte-by-byte Comparison</label>
                    <select id="byteComparison">
                        <option value="off">Off (Use Hash)</option>
                        <option value="partial">Partial (First 1MB)</option>
                        <option value="full">Full (Entire File)</option>
                    </select>
                </div>
                <div class="adv-col">
                    <label class="small">Similarity Threshold</label>
                    <input type="range" id="similarityThreshold" min="80" max="100" value="100">
                    <span class="small" id="thresholdValue">100% (Exact Match)</span>
                </div>
            </div>

            <div style="display:flex; gap:12px; align-items:center; margin-top: 20px;">
                <button class="btn btn-primary" id="scanBtn" disabled>üîç Scan for Duplicates</button>
                <button class="btn" id="clearBtn">Clear All</button>
                <div style="margin-left:auto" id="scanSummary" class="small"></div>
            </div>

            <div class="progress" id="progressWrap" style="display: none; margin-top: 15px;">
                <div class="bar" id="progressBar"></div>
            </div>

            <div class="tabs" style="margin-top: 20px;">
                <button class="tab-btn active" data-tab="results">Duplicate Results</button>
                <button class="tab-btn" data-tab="statistics">Statistics</button>
                <button class="tab-btn" data-tab="preview">File Preview</button>
                <button class="tab-btn" data-tab="settings">Scan Settings</button>
            </div>

            <!-- Results Tab -->
            <div class="tab-content active" id="results">
                <div style="margin-top: 15px;">
                    <div class="advanced-controls">
                        <button class="btn" id="selectAllDupes">Select All Duplicates</button>
                        <button class="btn" id="deselectAllBtn">Deselect All</button>
                        <button class="btn" id="keepNewestBtn">Keep Newest</button>
                        <button class="btn" id="keepOldestBtn">Keep Oldest</button>
                        <button class="btn" id="invertSelectionBtn">Invert Selection</button>
                    </div>

                    <div id="resultsContainer" class="preview"
                        style="margin-top: 10px; max-height: 500px; overflow: auto;">
                        <div style="text-align: center; padding: 40px 20px; color: var(--muted);">
                            <p>No duplicates found yet</p>
                            <p class="small">Add files and click "Scan for Duplicates" to begin</p>
                        </div>
                    </div>

                    <div style="margin-top: 15px;">
                        <h3>Selected for Removal</h3>
                        <div id="selectedContainer" class="preview" style="min-height: 80px;">
                            <div style="text-align: center; padding: 20px; color: var(--muted);">
                                <p>No files selected for removal</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Statistics Tab -->
            <div class="tab-content" id="statistics">
                <div
                    style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-top: 15px;">
                    <div class="card" style="text-align: center;">
                        <h3>üìÅ Total Files</h3>
                        <div style="font-size: 28px; font-weight: bold; color: var(--brand);" id="statTotalFiles">0
                        </div>
                    </div>
                    <div class="card" style="text-align: center;">
                        <h3>üîÑ Duplicate Files</h3>
                        <div style="font-size: 28px; font-weight: bold; color: var(--brand2);" id="statDuplicates">0
                        </div>
                    </div>
                    <div class="card" style="text-align: center;">
                        <h3>üíæ Space Wasted</h3>
                        <div style="font-size: 28px; font-weight: bold; color: var(--accent);" id="statWasted">0 B</div>
                    </div>
                    <div class="card" style="text-align: center;">
                        <h3>üéØ Potential Savings</h3>
                        <div style="font-size: 28px; font-weight: bold; color: var(--primary);" id="statSavings">0 B
                        </div>
                    </div>
                </div>

                <div class="card" style="margin-top: 15px;">
                    <h3>Duplicate Distribution by Type</h3>
                    <table class="table-preview" id="typeDistribution">
                        <tr>
                            <th>File Type</th>
                            <th>Total Files</th>
                            <th>Duplicates</th>
                            <th>Space Wasted</th>
                            <th>% Duplicate</th>
                        </tr>
                        <tr>
                            <td colspan="5" style="text-align: center; color: var(--muted);">No data available</td>
                        </tr>
                    </table>
                </div>

                <div class="card" style="margin-top: 15px;">
                    <h3>üìä Scan Summary</h3>
                    <div id="scanStats" class="preview" style="padding: 15px;">
                        <div style="text-align: center; color: var(--muted);">
                            <p>Scan not performed yet</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Preview Tab -->
            <div class="tab-content" id="preview">
                <div style="margin-top: 15px;">
                    <div class="advanced-controls">
                        <input type="text" id="searchPreview" placeholder="Search duplicates..." style="flex: 1;">
                        <button class="btn" id="compareBtn">Compare Files</button>
                        <button class="btn" id="viewOriginalsBtn">View Originals</button>
                    </div>

                    <div style="display: flex; gap: 20px; margin-top: 15px;">
                        <div style="flex: 1;">
                            <h4>File Comparison</h4>
                            <div id="fileComparison" class="preview" style="height: 300px; overflow: auto;">
                                <div style="text-align: center; padding: 40px 20px; color: var(--muted);">
                                    <p>Select duplicate group to compare files</p>
                                </div>
                            </div>
                        </div>
                        <div style="flex: 1;">
                            <h4>Image Preview (if available)</h4>
                            <div id="imagePreview" class="preview"
                                style="height: 300px; display: flex; align-items: center; justify-content: center;">
                                <div style="text-align: center; color: var(--muted);">
                                    <p>No image selected</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Settings Tab -->
            <div class="tab-content" id="settings">
                <div class="row" style="margin-top: 15px;">
                    <div class="col">
                        <div class="control">
                            <label>Scan Options</label>
                            <div class="optionRow">
                                <input type="checkbox" id="ignoreEmpty" checked>
                                <label for="ignoreEmpty" class="small">Ignore empty files (0 bytes)</label>
                            </div>
                            <div class="optionRow">
                                <input type="checkbox" id="ignoreSystem" checked>
                                <label for="ignoreSystem" class="small">Ignore system/hidden files</label>
                            </div>
                            <div class="optionRow">
                                <input type="checkbox" id="scanSubfolders" checked>
                                <label for="scanSubfolders" class="small">Scan subfolders recursively</label>
                            </div>
                            <div class="optionRow">
                                <input type="checkbox" id="caseSensitive" checked>
                                <label for="caseSensitive" class="small">Case-sensitive name comparison</label>
                            </div>
                        </div>
                    </div>
                    <div class="col">
                        <div class="control">
                            <label>Auto-Selection Rules</label>
                            <div class="optionRow">
                                <input type="checkbox" id="autoKeepNewest">
                                <label for="autoKeepNewest" class="small">Auto-keep newest file</label>
                            </div>
                            <div class="optionRow">
                                <input type="checkbox" id="autoKeepShortest">
                                <label for="autoKeepShortest" class="small">Auto-keep shortest path</label>
                            </div>
                            <div class="optionRow">
                                <input type="checkbox" id="autoKeepOriginal">
                                <label for="autoKeepOriginal" class="small">Auto-keep original (first found)</label>
                            </div>
                        </div>
                    </div>
                    <div class="col">
                        <div class="control">
                            <label>Performance Settings</label>
                            <div class="optionRow">
                                <label for="chunkSize" class="small">Hash chunk size:</label>
                                <select id="chunkSize" style="width: 120px;">
                                    <option value="65536">64 KB (Fast)</option>
                                    <option value="131072">128 KB</option>
                                    <option value="262144" selected>256 KB (Balanced)</option>
                                    <option value="524288">512 KB</option>
                                    <option value="1048576">1 MB (Accurate)</option>
                                </select>
                            </div>
                            <div class="optionRow">
                                <label for="maxFiles" class="small">Max files per scan:</label>
                                <select id="maxFiles" style="width: 120px;">
                                    <option value="100">100</option>
                                    <option value="500">500</option>
                                    <option value="1000" selected>1,000</option>
                                    <option value="5000">5,000</option>
                                    <option value="10000">10,000</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div style="display:flex; gap:12px; margin-top: 20px;">
                <button class="btn btn-primary" id="deleteBtn" disabled>üóëÔ∏è Delete Selected</button>
                <button class="btn" id="exportReportBtn" disabled>üìÑ Export Report</button>
                <button class="btn" id="saveSessionBtn">üíæ Save Session</button>
                <button class="btn" id="loadSessionBtn">üìÇ Load Session</button>
            </div>

            <div id="downloadSection" style="display: none; margin-top: 20px;">
                <h3>üì• Download Clean Files</h3>
                <div id="downloadContainer">
                    <!-- Download links will appear here -->
                </div>
            </div>

            <div class="card" style="margin-top: 20px; background: rgba(255,255,255,0.02);">
                <h3>üí° Duplicate Finding Tips</h3>
                <ul class="about-points">
                    <li><strong>Start with quick scan:</strong> Use file size and name comparison first for speed</li>
                    <li><strong>Verify before deleting:</strong> Always preview files before marking for deletion</li>
                    <li><strong>Keep originals:</strong> When in doubt, keep the file with the original/earliest date
                    </li>
                    <li><strong>Check file contents:</strong> Files with same size but different names might still be
                        duplicates</li>
                    <li><strong>Backup important files:</strong> Always keep backups before deleting duplicates</li>
                </ul>
            </div>
        </div>

        <hr style="margin: 32px 0;">
        <section class="seo-content">
            <h2>About Duplicate File Finder</h2>
            <p>
                Duplicate File Finder helps you identify and remove duplicate files from your computer, freeing up
                valuable
                disk space. It uses multiple comparison methods including file size, name, content hash, and
                byte-by-byte
                comparison to ensure accurate detection. All processing happens locally in your browser for privacy and
                security.
            </p>

            <h2>How It Works</h2>
            <ol class="about-points">
                <li><strong>File Collection:</strong> Select files or folders to scan for duplicates</li>
                <li><strong>Initial Filtering:</strong> Files are grouped by size (different sizes cannot be duplicates)
                </li>
                <li><strong>Content Comparison:</strong> Files with same size are compared using hash algorithms or
                    direct
                    byte comparison</li>
                <li><strong>Duplicate Grouping:</strong> Identical files are grouped together for review</li>
                <li><strong>Selection & Removal:</strong> Choose which duplicates to keep and which to remove</li>
                <li><strong>Cleanup:</strong> Download cleaned files or generate deletion report</li>
            </ol>

            <h2>Comparison Methods</h2>
            <div
                style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin: 15px 0;">
                <div class="card" style="background: rgba(10, 163, 127, 0.1);">
                    <h4 style="color: #0aa37f;">‚ö° Quick Scan</h4>
                    <p class="small">Compares file sizes and names. Fastest method but may miss some duplicates if files
                        have
                        different names.</p>
                </div>
                <div class="card" style="background: rgba(14, 165, 233, 0.1);">
                    <h4 style="color: #0ea5e9;">üîç Content Scan</h4>
                    <p class="small">Reads file contents and compares byte patterns. More accurate but slower for large
                        files.
                    </p>
                </div>
                <div class="card" style="background: rgba(139, 92, 246, 0.1);">
                    <h4 style="color: #8b5cf6;">üîê Hash Comparison</h4>
                    <p class="small">Computes cryptographic hashes (MD5, SHA-1, SHA-256) for each file. Very accurate
                        and
                        efficient for comparison.</p>
                </div>
                <div class="card" style="background: rgba(245, 158, 11, 0.1);">
                    <h4 style="color: #f59e0b;">üéØ Advanced Scan</h4>
                    <p class="small">Combines multiple methods with configurable thresholds. Can find similar but not
                        identical
                        files.</p>
                </div>
            </div>

            <h2>Common Sources of Duplicate Files</h2>
            <ul class="about-points">
                <li><strong>Multiple Downloads:</strong> Downloading the same file multiple times to different locations
                </li>
                <li><strong>Backup Copies:</strong> Creating backups that include already existing files</li>
                <li><strong>Sync Conflicts:</strong> Cloud storage or sync services creating multiple versions</li>
                <li><strong>Software Installations:</strong> Applications copying the same files to multiple directories
                </li>
                <li><strong>Photo Imports:</strong> Importing photos from cameras or phones multiple times</li>
                <li><strong>Email Attachments:</strong> Saving the same attachment from multiple emails</li>
            </ul>

            <h2>Safety Features</h2>
            <ul class="about-points">
                <li><strong>Preview Before Delete:</strong> View file contents before marking for deletion</li>
                <li><strong>Auto-Selection Rules:</strong> Smart rules to automatically select which duplicates to keep
                </li>
                <li><strong>Undo Support:</strong> Multiple levels of undo for safe experimentation</li>
                <li><strong>Session Saving:</strong> Save scan results to resume later</li>
                <li><strong>Export Reports:</strong> Generate detailed reports of found duplicates</li>
                <li><strong>No Permanent Deletion:</strong> Files are only removed from the list, not from your computer
                </li>
            </ul>

            <h2>Technical Details</h2>
            <p>
                Duplicate File Finder uses the HTML5 File API to read files locally in your browser. For hash
                computation,
                it uses the Web Crypto API where available, with fallbacks to JavaScript implementations. The tool can
                handle thousands of files, though performance depends on file sizes and your computer's specifications.
                For very large files (>100MB), consider using the quick scan option or limiting the scan to specific
                folders.
            </p>
            <h2>Related System Tools</h2>
            <p>
                You might also find these system tools useful:
            <ul class="about-points">
                <li><a href="/windows-tools/system/startup-program-manager.html" class="btn tools">Startup Manager</a> -
                    Manage which
                    programs
                    at startup.</li>
                <li><a href="/windows-tools/system/file-renamer.html" class="btn tools">Bulk File Renamer</a> - Rename
                    multiple files
                    once using patterns.</li>
                <li><a href="/windows-tools/system/folder-size-analyzer.html" class="btn tools">Folder Size Analyzer</a>
                    - View and manage
                    disk space usage by folder.</li>
            </ul>
            </p>

        </section>
    </section>

    <!-- FOOTER -->
    <div id="footer-container"></div>

    <script>
        function toggleMenu() {
            document.getElementById("drawer").classList.toggle("open");
        }
        // Tab switching
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const tabId = btn.getAttribute('data-tab');
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                document.getElementById(tabId).classList.add('active');
            });
        });

        // Elements
        const fileInput = document.getElementById('fileInput');
        const chooseBtn = document.getElementById('chooseBtn');
        const dropArea = document.getElementById('dropArea');
        const scanBtn = document.getElementById('scanBtn');
        const clearBtn = document.getElementById('clearBtn');
        const progressWrap = document.getElementById('progressWrap');
        const progressBar = document.getElementById('progressBar');
        const scanSummary = document.getElementById('scanSummary');
        const resultsContainer = document.getElementById('resultsContainer');
        const selectedContainer = document.getElementById('selectedContainer');
        const downloadSection = document.getElementById('downloadSection');
        const downloadContainer = document.getElementById('downloadContainer');

        // State
        let filesData = [];
        let duplicateGroups = [];
        let selectedForDeletion = new Set();
        let fileHashes = new Map();
        let scanSession = null;

        // File selection
        chooseBtn.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', handleFileSelection);

        // Drag and drop
        dropArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropArea.classList.add('dragover');
        });
        dropArea.addEventListener('dragleave', () => dropArea.classList.remove('dragover'));
        dropArea.addEventListener('drop', (e) => {
            e.preventDefault();
            dropArea.classList.remove('dragover');
            if (e.dataTransfer.items) {
                handleFileDrop(e.dataTransfer.items);
            } else {
                processFileList(e.dataTransfer.files);
            }
        });

        // Handle file selection
        function handleFileSelection(e) {
            const fileList = e.target.files;
            processFileList(fileList);
        }

        // Handle file drop with directory support
        function handleFileDrop(items) {
            filesData = [];
            const processEntry = (entry, path = '') => {
                return new Promise((resolve) => {
                    if (entry.isFile) {
                        entry.file(file => {
                            addFileData(file, path + entry.name);
                            resolve();
                        });
                    } else if (entry.isDirectory) {
                        const reader = entry.createReader();
                        reader.readEntries(entries => {
                            const promises = entries.map(childEntry =>
                                processEntry(childEntry, path + entry.name + '/')
                            );
                            Promise.all(promises).then(resolve);
                        });
                    }
                });
            };

            const promises = [];
            for (let i = 0; i < items.length; i++) {
                const entry = items[i].webkitGetAsEntry();
                if (entry) {
                    promises.push(processEntry(entry));
                }
            }

            Promise.all(promises).then(() => {
                updateScanSummary();
                scanBtn.disabled = filesData.length === 0;
            });
        }

        // Process file list
        function processFileList(fileList) {
            for (let i = 0; i < fileList.length; i++) {
                const file = fileList[i];
                addFileData(file, file.webkitRelativePath || file.name);
            }
            updateScanSummary();
            scanBtn.disabled = filesData.length === 0;
        }

        // Add file data object
        function addFileData(file, path) {
            const name = file.name;
            const extension = name.includes('.') ? name.split('.').pop().toLowerCase() : '';
            const nameWithoutExt = name.includes('.') ? name.substring(0, name.lastIndexOf('.')) : name;

            filesData.push({
                id: Date.now() + Math.random(),
                originalFile: file,
                originalName: name,
                path: path,
                nameWithoutExt: nameWithoutExt,
                extension: extension,
                size: file.size,
                type: file.type,
                lastModified: file.lastModified,
                hash: null,
                groupId: null,
                isDuplicate: false,
                keep: true,
                selected: false
            });
        }

        // Update scan summary
        function updateScanSummary() {
            const totalSize = filesData.reduce((sum, f) => sum + f.size, 0);
            const sizeMB = (totalSize / (1024 * 1024)).toFixed(2);

            scanSummary.textContent = `${filesData.length} files ‚Ä¢ ${sizeMB} MB`;
        }

        // Scan for duplicates
        scanBtn.addEventListener('click', async () => {
            if (filesData.length === 0) {
                alert('Please add files to scan first.');
                return;
            }

            scanBtn.disabled = true;
            scanBtn.textContent = 'Scanning...';
            progressWrap.style.display = 'block';
            progressBar.style.width = '0%';

            // Reset previous results
            duplicateGroups = [];
            selectedForDeletion.clear();
            fileHashes.clear();

            const scanMethod = document.getElementById('scanMethod').value;
            const minSize = parseInt(document.getElementById('minSize').value);

            // Filter files by minimum size
            let filesToScan = filesData.filter(f => f.size >= minSize);

            // Filter by file type if needed
            const fileTypes = document.getElementById('fileTypes').value;
            if (fileTypes !== 'all') {
                const extensions = {
                    images: ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp'],
                    documents: ['pdf', 'doc', 'docx', 'txt', 'rtf', 'odt'],
                    media: ['mp3', 'mp4', 'avi', 'mkv', 'wav', 'flac']
                };

                if (fileTypes === 'custom') {
                    const customExts = document.getElementById('customTypes').value
                        .split(',')
                        .map(ext => ext.trim().replace(/^\./, ''));
                    filesToScan = filesToScan.filter(f => customExts.includes(f.extension));
                } else {
                    filesToScan = filesToScan.filter(f => extensions[fileTypes].includes(f.extension));
                }
            }

            // Group by size first (files with different sizes cannot be identical)
            const sizeGroups = {};
            filesToScan.forEach(file => {
                if (!sizeGroups[file.size]) {
                    sizeGroups[file.size] = [];
                }
                sizeGroups[file.size].push(file);
            });

            // Remove groups with only one file
            Object.keys(sizeGroups).forEach(size => {
                if (sizeGroups[size].length < 2) {
                    delete sizeGroups[size];
                }
            });

            let processed = 0;
            const totalGroups = Object.keys(sizeGroups).length;

            // Process each size group
            for (const [size, files] of Object.entries(sizeGroups)) {
                if (files.length > 1) {
                    let groups = [];

                    if (scanMethod === 'quick') {
                        // Quick scan: group by name
                        const nameGroups = {};
                        files.forEach(file => {
                            const key = file.originalName.toLowerCase();
                            if (!nameGroups[key]) {
                                nameGroups[key] = [];
                            }
                            nameGroups[key].push(file);
                        });

                        // Create duplicate groups
                        Object.values(nameGroups).forEach(group => {
                            if (group.length > 1) {
                                groups.push(group);
                            }
                        });
                    } else {
                        // Content or hash scan: compute hashes
                        const hashGroups = {};

                        for (const file of files) {
                            const hash = await computeFileHash(file, scanMethod);
                            file.hash = hash;

                            if (!hashGroups[hash]) {
                                hashGroups[hash] = [];
                            }
                            hashGroups[hash].push(file);
                        }

                        // Create duplicate groups
                        Object.values(hashGroups).forEach(group => {
                            if (group.length > 1) {
                                groups.push(group);
                            }
                        });
                    }

                    // Add to duplicate groups
                    groups.forEach(group => {
                        const groupId = `group-${duplicateGroups.length}`;
                        group.forEach(file => {
                            file.groupId = groupId;
                            file.isDuplicate = true;
                        });
                        duplicateGroups.push({
                            id: groupId,
                            files: group,
                            size: parseInt(size),
                            totalSize: group.length * parseInt(size)
                        });
                    });
                }

                // Update progress
                processed++;
                const progress = (processed / totalGroups) * 100;
                progressBar.style.width = `${progress}%`;
                progressBar.textContent = `${Math.round(progress)}%`;
            }

            // Update UI
            updateResults();
            updateStatistics();
            scanSession = {
                timestamp: new Date().toISOString(),
                files: filesData.length,
                duplicates: duplicateGroups.length,
                totalWasted: calculateWastedSpace()
            };

            scanBtn.disabled = false;
            scanBtn.textContent = 'üîç Scan for Duplicates';
            progressWrap.style.display = 'none';
            document.getElementById('deleteBtn').disabled = selectedForDeletion.size === 0;
            document.getElementById('exportReportBtn').disabled = duplicateGroups.length === 0;
        });

        // Compute file hash
        async function computeFileHash(file, method) {
            if (file.hash) return file.hash;

            if (method === 'content') {
                // Simple content comparison - use first 1MB
                return await getFileChunkHash(file.originalFile, 1024 * 1024);
            } else {
                // Full hash
                const algorithm = document.getElementById('hashAlgorithm').value;
                return await getFullFileHash(file.originalFile, algorithm);
            }
        }

        // Get hash of file chunk
        async function getFileChunkHash(file, chunkSize) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                const blob = file.slice(0, Math.min(chunkSize, file.size));

                reader.onload = (e) => {
                    const wordArray = CryptoJS.lib.WordArray.create(e.target.result);
                    const hash = CryptoJS.MD5(wordArray).toString();
                    resolve(hash);
                };

                reader.readAsArrayBuffer(blob);
            });
        }

        // Get full file hash
        async function getFullFileHash(file, algorithm) {
            return new Promise((resolve) => {
                const reader = new FileReader();

                reader.onload = (e) => {
                    const wordArray = CryptoJS.lib.WordArray.create(e.target.result);
                    let hash;

                    switch (algorithm) {
                        case 'md5':
                            hash = CryptoJS.MD5(wordArray).toString();
                            break;
                        case 'sha1':
                            hash = CryptoJS.SHA1(wordArray).toString();
                            break;
                        case 'sha256':
                            hash = CryptoJS.SHA256(wordArray).toString();
                            break;
                        default:
                            hash = CryptoJS.MD5(wordArray).toString();
                    }

                    resolve(hash);
                };

                reader.readAsArrayBuffer(file);
            });
        }

        // Update results display
        function updateResults() {
            if (duplicateGroups.length === 0) {
                resultsContainer.innerHTML = `
          <div style="text-align: center; padding: 40px 20px; color: var(--muted);">
            <p>No duplicates found</p>
            <p class="small">Try changing scan settings or adding more files</p>
          </div>
        `;
                return;
            }

            let html = '';
            let groupIndex = 1;

            duplicateGroups.forEach(group => {
                html += `
          <div class="card" style="margin-bottom: 15px; background: rgba(255,255,255,0.03);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
              <h4>Duplicate Group ${groupIndex} (${group.files.length} files, ${formatSize(group.totalSize)} wasted)</h4>
              <button class="btn" data-action="selectGroup" data-group="${group.id}" style="padding: 4px 8px; font-size: 12px;">
                Select All in Group
              </button>
            </div>
        `;

                group.files.forEach((file, fileIndex) => {
                    const isSelected = selectedForDeletion.has(file.id);
                    const date = new Date(file.lastModified).toLocaleDateString();
                    const fileSize = formatSize(file.size);

                    html += `
            <div class="file-item" data-id="${file.id}">
              <div style="display: flex; align-items: center; gap: 10px;">
                <input type="checkbox" class="file-select" ${isSelected ? 'checked' : ''} data-id="${file.id}">
                <div style="width: 24px; height: 24px; border-radius: 4px; background: ${getFileColor(file.extension)}; display: flex; align-items: center; justify-content: center; font-weight: bold;">
                  ${getFileIcon(file.extension)}
                </div>
              </div>
              <div style="flex: 1; min-width: 0;">
                <div style="font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;" title="${file.originalName}">
                  ${file.originalName}
                </div>
                <div class="small" style="color: var(--muted);">
                  ${file.path} ‚Ä¢ ${date}
                </div>
              </div>
              <div class="file-meta">${fileSize}</div>
              <div class="file-actions">
                <button class="btn" data-action="preview" data-id="${file.id}" style="padding: 4px 8px; font-size: 12px;">Preview</button>
                <button class="btn" data-action="keep" data-id="${file.id}" style="padding: 4px 8px; font-size: 12px;">Keep</button>
                ${fileIndex === 0 ? '<span class="small" style="color: var(--brand);">(Original)</span>' : ''}
              </div>
            </div>
          `;
                });

                html += '</div>';
                groupIndex++;
            });

            resultsContainer.innerHTML = html;

            // Attach event listeners
            resultsContainer.querySelectorAll('.file-select').forEach(checkbox => {
                checkbox.addEventListener('change', (e) => {
                    const id = e.target.dataset.id;
                    toggleFileSelection(id, e.target.checked);
                });
            });

            resultsContainer.querySelectorAll('button[data-action="selectGroup"]').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const groupId = e.target.dataset.group;
                    selectDuplicateGroup(groupId);
                });
            });

            resultsContainer.querySelectorAll('button[data-action="preview"]').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const id = e.target.dataset.id;
                    previewFile(id);
                });
            });

            resultsContainer.querySelectorAll('button[data-action="keep"]').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const id = e.target.dataset.id;
                    keepFile(id);
                });
            });

            updateSelectedContainer();
        }

        // Get file color
        function getFileColor(ext) {
            const colorMap = {
                'jpg': '#ef4444', 'jpeg': '#ef4444', 'png': '#3b82f6', 'gif': '#8b5cf6',
                'pdf': '#ef4444', 'doc': '#0ea5e9', 'docx': '#0ea5e9', 'txt': '#9ca3af',
                'mp3': '#10b981', 'mp4': '#f59e0b', 'avi': '#f59e0b', 'zip': '#6366f1'
            };
            return colorMap[ext] || '#6b7280';
        }

        // Get file icon
        function getFileIcon(ext) {
            const icons = {
                'jpg': 'üñºÔ∏è', 'jpeg': 'üñºÔ∏è', 'png': 'üñºÔ∏è', 'gif': 'üñºÔ∏è',
                'pdf': 'üìÑ', 'doc': 'üìÑ', 'docx': 'üìÑ', 'txt': 'üìÑ',
                'mp3': 'üéµ', 'mp4': 'üé¨', 'avi': 'üé¨', 'wav': 'üéµ',
                'zip': 'üì¶', 'rar': 'üì¶', '7z': 'üì¶'
            };
            return icons[ext] || 'üìÅ';
        }

        // Format size
        function formatSize(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
        }

        // Toggle file selection
        function toggleFileSelection(id, selected) {
            const file = filesData.find(f => f.id === id);
            if (!file) return;

            if (selected) {
                selectedForDeletion.add(id);
                file.selected = true;
                file.keep = false;
            } else {
                selectedForDeletion.delete(id);
                file.selected = false;
                file.keep = true;
            }

            updateSelectedContainer();
            document.getElementById('deleteBtn').disabled = selectedForDeletion.size === 0;
        }

        // Select entire duplicate group
        function selectDuplicateGroup(groupId) {
            const group = duplicateGroups.find(g => g.id === groupId);
            if (!group) return;

            // Select all except the first file (keep original)
            group.files.forEach((file, index) => {
                if (index > 0) { // Skip the first file (original)
                    selectedForDeletion.add(file.id);
                    file.selected = true;
                    file.keep = false;
                }
            });

            updateResults();
            updateSelectedContainer();
            document.getElementById('deleteBtn').disabled = selectedForDeletion.size === 0;
        }

        // Keep file (remove from deletion list)
        function keepFile(id) {
            selectedForDeletion.delete(id);
            const file = filesData.find(f => f.id === id);
            if (file) {
                file.selected = false;
                file.keep = true;
            }
            updateResults();
            updateSelectedContainer();
            document.getElementById('deleteBtn').disabled = selectedForDeletion.size === 0;
        }

        // Update selected container
        function updateSelectedContainer() {
            if (selectedForDeletion.size === 0) {
                selectedContainer.innerHTML = `
          <div style="text-align: center; padding: 20px; color: var(--muted);">
            <p>No files selected for removal</p>
          </div>
        `;
                return;
            }

            let totalSize = 0;
            let html = '<div class="files-list">';

            selectedForDeletion.forEach(id => {
                const file = filesData.find(f => f.id === id);
                if (file) {
                    totalSize += file.size;
                    html += `
            <div class="file-item">
              <div style="display: flex; align-items: center; gap: 10px;">
                <div style="color: var(--brand);">üóëÔ∏è</div>
                <div>
                  <div style="font-weight: 500;">${file.originalName}</div>
                  <div class="small" style="color: var(--muted);">${formatSize(file.size)}</div>
                </div>
              </div>
              <button class="btn" data-action="unselect" data-id="${id}" style="padding: 4px 8px; font-size: 12px;">Keep</button>
            </div>
          `;
                }
            });

            html += `</div>
        <div style="margin-top: 10px; padding: 10px; background: rgba(239, 68, 68, 0.1); border-radius: 6px;">
          <strong>Total space to recover:</strong> ${formatSize(totalSize)}
        </div>
      `;

            selectedContainer.innerHTML = html;

            // Attach unselect event listeners
            selectedContainer.querySelectorAll('button[data-action="unselect"]').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const id = e.target.dataset.id;
                    toggleFileSelection(id, false);
                });
            });
        }

        // Update statistics
        function updateStatistics() {
            const totalDuplicates = duplicateGroups.reduce((sum, group) => sum + group.files.length, 0);
            const uniqueDuplicates = duplicateGroups.length;
            const wastedSpace = calculateWastedSpace();
            const potentialSavings = calculatePotentialSavings();

            document.getElementById('statTotalFiles').textContent = filesData.length;
            document.getElementById('statDuplicates').textContent = totalDuplicates;
            document.getElementById('statWasted').textContent = formatSize(wastedSpace);
            document.getElementById('statSavings').textContent = formatSize(potentialSavings);

            // Update type distribution
            updateTypeDistribution();

            // Update scan stats
            const scanStats = document.getElementById('scanStats');
            scanStats.innerHTML = `
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
          <div><strong>Scan Method:</strong> ${document.getElementById('scanMethod').options[document.getElementById('scanMethod').selectedIndex].text}</div>
          <div><strong>Files Scanned:</strong> ${filesData.length}</div>
          <div><strong>Duplicate Groups:</strong> ${uniqueDuplicates}</div>
          <div><strong>Total Duplicates:</strong> ${totalDuplicates}</div>
          <div><strong>Space Wasted:</strong> ${formatSize(wastedSpace)}</div>
          <div><strong>Scan Date:</strong> ${new Date().toLocaleDateString()}</div>
        </div>
      `;
        }

        // Calculate wasted space
        function calculateWastedSpace() {
            let wasted = 0;
            duplicateGroups.forEach(group => {
                // For each group, wasted space = (number of duplicates - 1) * file size
                wasted += (group.files.length - 1) * group.size;
            });
            return wasted;
        }

        // Calculate potential savings
        function calculatePotentialSavings() {
            let savings = 0;
            selectedForDeletion.forEach(id => {
                const file = filesData.find(f => f.id === id);
                if (file) savings += file.size;
            });
            return savings;
        }

        // Update type distribution
        function updateTypeDistribution() {
            const typeMap = {};

            duplicateGroups.forEach(group => {
                group.files.forEach(file => {
                    const ext = file.extension || 'unknown';
                    if (!typeMap[ext]) {
                        typeMap[ext] = {
                            totalFiles: 0,
                            duplicates: 0,
                            wasted: 0
                        };
                    }
                    typeMap[ext].totalFiles++;
                    typeMap[ext].duplicates++;
                    typeMap[ext].wasted += file.size;
                });
            });

            const table = document.getElementById('typeDistribution');
            let html = '<tr><th>File Type</th><th>Total Files</th><th>Duplicates</th><th>Space Wasted</th><th>% Duplicate</th></tr>';

            if (Object.keys(typeMap).length === 0) {
                html += '<tr><td colspan="5" style="text-align: center; color: var(--muted);">No duplicate data available</td></tr>';
            } else {
                Object.entries(typeMap).forEach(([ext, data]) => {
                    const percentage = ((data.duplicates / data.totalFiles) * 100).toFixed(1);
                    html += `
            <tr>
              <td>.${ext}</td>
              <td>${data.totalFiles}</td>
              <td>${data.duplicates}</td>
              <td>${formatSize(data.wasted)}</td>
              <td>${percentage}%</td>
            </tr>
          `;
                });
            }

            table.innerHTML = html;
        }

        // Preview file
        function previewFile(id) {
            const file = filesData.find(f => f.id === id);
            if (!file) return;

            const preview = document.getElementById('imagePreview');

            if (file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    preview.innerHTML = `<img src="${e.target.result}" style="max-width: 100%; max-height: 100%; border-radius: 6px;">`;
                };
                reader.readAsDataURL(file.originalFile);
            } else {
                preview.innerHTML = `
          <div style="text-align: center;">
            <div style="font-size: 48px;">${getFileIcon(file.extension)}</div>
            <h4>${file.originalName}</h4>
            <p class="small">Size: ${formatSize(file.size)}</p>
            <p class="small">Type: ${file.type || 'Unknown'}</p>
            <p class="small">Modified: ${new Date(file.lastModified).toLocaleString()}</p>
          </div>
        `;
            }
        }

        // Delete selected files
        document.getElementById('deleteBtn').addEventListener('click', async () => {
            if (selectedForDeletion.size === 0) {
                alert('No files selected for deletion.');
                return;
            }

            if (!confirm(`Remove ${selectedForDeletion.size} duplicate files? This will free ${formatSize(calculatePotentialSavings())} of space.`)) {
                return;
            }

            // Filter out selected files
            const filesToKeep = filesData.filter(f => !selectedForDeletion.has(f.id));

            if (filesToKeep.length === 0) {
                alert('Cannot delete all files. At least one file must remain.');
                return;
            }

            // Create zip of remaining files
            progressWrap.style.display = 'block';
            progressBar.style.width = '0%';
            progressBar.textContent = '0%';

            const zip = new JSZip();
            let processed = 0;

            for (const file of filesToKeep) {
                zip.file(file.originalName, file.originalFile);
                processed++;

                const progress = (processed / filesToKeep.length) * 100;
                progressBar.style.width = `${progress}%`;
                progressBar.textContent = `${Math.round(progress)}%`;

                await new Promise(resolve => setTimeout(resolve, 10));
            }

            // Generate and download zip
            const zipBlob = await zip.generateAsync({ type: 'blob' });
            const url = URL.createObjectURL(zipBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `clean_files_${Date.now()}.zip`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            // Update UI
            progressWrap.style.display = 'none';
            downloadSection.style.display = 'block';

            downloadContainer.innerHTML = `
        <div class="card" style="background: rgba(10, 163, 127, 0.1);">
          <h4 style="color: #0aa37f;">‚úÖ Clean Files Downloaded</h4>
          <p>${filesToKeep.length} files (${formatSize(filesToKeep.reduce((sum, f) => sum + f.size, 0))}) have been saved to the ZIP file.</p>
          <p class="small">Original duplicate files were not modified on your system.</p>
        </div>
      `;

            // Clear selection
            selectedForDeletion.clear();
            updateSelectedContainer();
            document.getElementById('deleteBtn').disabled = true;
        });

        // Export report
        document.getElementById('exportReportBtn').addEventListener('click', () => {
            if (duplicateGroups.length === 0) return;

            const report = {
                title: 'Duplicate File Finder Report',
                generated: new Date().toISOString(),
                scanMethod: document.getElementById('scanMethod').value,
                totalFiles: filesData.length,
                duplicateGroups: duplicateGroups.length,
                totalDuplicates: duplicateGroups.reduce((sum, g) => sum + g.files.length, 0),
                wastedSpace: calculateWastedSpace(),
                potentialSavings: calculatePotentialSavings(),
                groups: duplicateGroups.map(group => ({
                    size: group.size,
                    fileCount: group.files.length,
                    wasted: (group.files.length - 1) * group.size,
                    files: group.files.map(f => ({
                        name: f.originalName,
                        path: f.path,
                        size: f.size,
                        modified: new Date(f.lastModified).toISOString(),
                        hash: f.hash
                    }))
                })),
                settings: {
                    minSize: document.getElementById('minSize').value,
                    fileTypes: document.getElementById('fileTypes').value,
                    algorithm: document.getElementById('hashAlgorithm').value
                }
            };

            const dataStr = JSON.stringify(report, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);
            const exportFileDefaultName = `duplicate-report-${new Date().toISOString().slice(0, 10)}.json`;

            const linkElement = document.createElement('a');
            linkElement.setAttribute('href', dataUri);
            linkElement.setAttribute('download', exportFileDefaultName);
            linkElement.click();
        });

        // Save session
        document.getElementById('saveSessionBtn').addEventListener('click', () => {
            const session = {
                timestamp: new Date().toISOString(),
                files: filesData.map(f => ({
                    name: f.originalName,
                    size: f.size,
                    lastModified: f.lastModified,
                    path: f.path
                })),
                duplicateGroups: duplicateGroups,
                selectedForDeletion: Array.from(selectedForDeletion)
            };

            const dataStr = JSON.stringify(session, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);
            const sessionName = `duplicate-session-${new Date().toISOString().slice(0, 10)}.json`;

            const linkElement = document.createElement('a');
            linkElement.setAttribute('href', dataUri);
            linkElement.setAttribute('download', sessionName);
            linkElement.click();
        });

        // Load session
        document.getElementById('loadSessionBtn').addEventListener('click', () => {
            alert('Session loading would require re-uploading the original files. For now, please re-scan with the same files.');
        });

        // Clear all files
        clearBtn.addEventListener('click', () => {
            if (filesData.length === 0) return;

            if (confirm(`Clear all ${filesData.length} files and scan results?`)) {
                filesData = [];
                duplicateGroups = [];
                selectedForDeletion.clear();
                fileHashes.clear();

                updateScanSummary();
                updateResults();
                updateStatistics();
                scanBtn.disabled = true;
                downloadSection.style.display = 'none';
                document.getElementById('deleteBtn').disabled = true;
                document.getElementById('exportReportBtn').disabled = true;
            }
        });

        // Event listeners for controls
        document.getElementById('scanMethod').addEventListener('change', (e) => {
            const advancedOptions = document.getElementById('advancedOptions');
            advancedOptions.style.display = e.target.value === 'advanced' ? 'flex' : 'none';
        });

        document.getElementById('fileTypes').addEventListener('change', (e) => {
            document.getElementById('customTypes').style.display =
                e.target.value === 'custom' ? 'block' : 'none';
        });

        document.getElementById('similarityThreshold').addEventListener('input', (e) => {
            document.getElementById('thresholdValue').textContent = `${e.target.value}% ${e.target.value < 100 ? '(Similar)' : '(Exact Match)'}`;
        });

        // Button event listeners
        document.getElementById('selectAllDupes').addEventListener('click', () => {
            duplicateGroups.forEach(group => {
                selectDuplicateGroup(group.id);
            });
        });

        document.getElementById('deselectAllBtn').addEventListener('click', () => {
            selectedForDeletion.clear();
            filesData.forEach(f => {
                f.selected = false;
                f.keep = true;
            });
            updateResults();
            updateSelectedContainer();
            document.getElementById('deleteBtn').disabled = true;
        });

        document.getElementById('keepNewestBtn').addEventListener('click', () => {
            duplicateGroups.forEach(group => {
                // Find newest file
                let newestIndex = 0;
                let newestDate = 0;

                group.files.forEach((file, index) => {
                    if (file.lastModified > newestDate) {
                        newestDate = file.lastModified;
                        newestIndex = index;
                    }
                });

                // Keep newest, select others
                group.files.forEach((file, index) => {
                    if (index !== newestIndex) {
                        selectedForDeletion.add(file.id);
                        file.selected = true;
                        file.keep = false;
                    }
                });
            });

            updateResults();
            updateSelectedContainer();
            document.getElementById('deleteBtn').disabled = selectedForDeletion.size === 0;
        });

        document.getElementById('keepOldestBtn').addEventListener('click', () => {
            duplicateGroups.forEach(group => {
                // Find oldest file
                let oldestIndex = 0;
                let oldestDate = Date.now();

                group.files.forEach((file, index) => {
                    if (file.lastModified < oldestDate) {
                        oldestDate = file.lastModified;
                        oldestIndex = index;
                    }
                });

                // Keep oldest, select others
                group.files.forEach((file, index) => {
                    if (index !== oldestIndex) {
                        selectedForDeletion.add(file.id);
                        file.selected = true;
                        file.keep = false;
                    }
                });
            });

            updateResults();
            updateSelectedContainer();
            document.getElementById('deleteBtn').disabled = selectedForDeletion.size === 0;
        });

        document.getElementById('invertSelectionBtn').addEventListener('click', () => {
            duplicateGroups.forEach(group => {
                group.files.forEach(file => {
                    if (selectedForDeletion.has(file.id)) {
                        selectedForDeletion.delete(file.id);
                        file.selected = false;
                        file.keep = true;
                    } else {
                        selectedForDeletion.add(file.id);
                        file.selected = true;
                        file.keep = false;
                    }
                });
            });

            updateResults();
            updateSelectedContainer();
            document.getElementById('deleteBtn').disabled = selectedForDeletion.size === 0;
        });

        // Initialize
        updateScanSummary();
    </script>
</body>

</html>
